export { parseProjectToml } from './parse';

import type { VideoInfo } from '../../types';
import type { Project } from './types';
import { getDominantColor, getShuffled, getThumbnail, removeDuplicate } from './utils.js';
import { fetchPlaylist, fetchVideos, isAutoGeneratedVideo } from './youtube.js';

export const fetchFromProject = async (project: Project, apiKey: string): Promise<VideoInfo[]> => {
	const ignoreIds = removeDuplicate(...(project.ignore?.map(({ id }) => id) ?? []));
	const idTagMap: Record<string, string[]> = {};

	const duplicateDefinitions = [];

	const videos: Record<string, VideoInfo> = {};

	console.log('Fetching playlists...');
	for (const playlist of project.playlist ?? []) {
		const videosInPlaylist = await fetchPlaylist(apiKey, playlist.id).catch(
			(err) => (console.warn(`Error playlist(${playlist.id}):`, err), [])
		);
		const tags = playlist.tags ?? [];
		videosInPlaylist.forEach(({ resourceId }) => {
			if (resourceId?.videoId == null) return;
			const exist = idTagMap[resourceId.videoId] ?? [];
			idTagMap[resourceId.videoId] = removeDuplicate(...tags, ...exist);
		});
	}
	console.log('Fetched playlists.');

	for (const video of project.video ?? []) {
		const existTag = idTagMap[video.id];
		const specifiedTag = video.tags ?? [];
		if (existTag == null) {
			idTagMap[video.id] = specifiedTag ?? [];
		} else if (
			existTag.length >= specifiedTag.length &&
			specifiedTag.every((t) => existTag.includes(t))
		) {
			duplicateDefinitions.push(video.id);
		} else {
			idTagMap[video.id] = removeDuplicate(...existTag, ...specifiedTag);
		}
	}

	const videoIds = Object.keys(idTagMap).filter((id) => !ignoreIds.includes(id));

	console.log('Fetching videos...');
	if (videoIds.length > 0) {
		const videosRes = await fetchVideos(apiKey, videoIds);
		await videosRes.reduce(async (prev, { id, snippet, status }) => {
			await prev;
			if (
				snippet?.liveBroadcastContent !== 'none' ||
				status?.privacyStatus !== 'public' ||
				!status.embeddable ||
				id == null ||
				snippet == null
			)
				return;
			const thumbnail = snippet.thumbnails && getThumbnail(snippet.thumbnails);
			if (thumbnail == null) return;
			videos[id] = {
				title: snippet.title ?? '',
				id,
				thumbnail,
				color: await getDominantColor(thumbnail.url ?? ''),
				squareThumbnail: isAutoGeneratedVideo(snippet?.description ?? ''),
				description: snippet?.description ?? '',
				tags: idTagMap[id] ?? []
			};
			const publishedTimestamp = new Date(snippet.publishedAt ?? '').valueOf();
			if (Date.now() - publishedTimestamp <= 30 * 24 * 60 * 60 * 1000) videos[id].tags?.push('NEW');
		}, Promise.resolve());
	}
	console.log('Fetched videos.');

	const videoList = Object.values(videos);
	console.log(`Complete with ${Object.keys(videos).length} videos!!!`);
	if (duplicateDefinitions.length > 0)
		console.warn(`Duplicate definitions found: ${duplicateDefinitions.join(', ')}`);

	const notagVideos = videoList.filter(({ tags }) => tags?.length === 0);
	if (notagVideos.length > 0)
		console.warn(`No tag video found: ${notagVideos.map(({ id }) => id).join(', ')}`);

	return getShuffled(videoList);
};
