/* eslint-disable @typescript-eslint/ban-ts-comment */
// @ts-check
import TOML from '@iarna/toml';
import { getPalette } from 'colorthief';
import { google } from 'googleapis';
import { readFile, writeFile } from 'node:fs/promises';
import { dirname, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';

/**
 * @param {string} playlistId Playlist ID
 * @param {string} pageToken nextPageToken
 * @returns {Promise<import('googleapis').youtube_v3.Schema$PlaylistItemSnippet[]>}
 */
const fetchPlaylist = async (playlistId, pageToken = undefined) => {
	const res = await google.youtube('v3').playlistItems.list({
		key: process.env.API_KEY,
		part: ['snippet'],
		maxResults: 50,
		playlistId,
		pageToken
	});

	return res.data.items?.map((item) => item.snippet)?.filter((item) => item != null) ?? [];
};

/**
 * @param {string[]} videoIds Video ID
 * @param {string} pageToken nextPageToken
 * @returns {Promise<import('googleapis').youtube_v3.Schema$Video[]>}
 */
const fetchVideos = async (videoIds, pageToken = undefined) => {
	const res = await google.youtube('v3').videos.list({
		key: process.env.API_KEY,
		part: ['snippet'],
		maxResults: 50,
		id: videoIds,
		pageToken
	});

	return res.data.items ?? [];
};

/**
 * @param {import('googleapis').youtube_v3.Schema$ThumbnailDetails} thumbnailObject
 * @returns {import('googleapis').youtube_v3.Schema$Thumbnail}
 */
const getThumbnail = (thumbnailObject) =>
	thumbnailObject.maxres ?? // ~1280x720
	thumbnailObject.standard ?? // ~640x480
	thumbnailObject.high ?? // ~480x360
	thumbnailObject.medium ?? // ~320x180
	thumbnailObject.default; // ~120x90

/**
 * @param {string} imgUrl
 * @returns {Promise<string>}
 */
const getDominantColor = async (imgUrl) => {
	/** @type {[number, number, number][]} */
	const [dominantColor] = await getPalette(imgUrl, 2, 2);
	return `#${dominantColor.map((v) => v.toString(16).padStart(2, '0')).join('')}`;
};

/**
 * @param {string} description
 * @returns {boolean}
 */
const isAutoGeneratedVideo = (description) =>
	description.match(/^Provided to YouTube.+Auto-generated by YouTube\.$/s) != null;

/**
 * @param {string | undefined} tomlPath
 */
const main = async (tomlPath) => {
	// @ts-ignore
	const __dirname = dirname(fileURLToPath(import.meta.url));
	const _tomlPath = (tomlPath === undefined)
		? resolve(__dirname, '..', 'project.toml')
		: resolve(tomlPath);

	const projectToml = await readFile(_tomlPath, 'utf8');
	const project = TOML.parse(projectToml);

	/** @type {Set<string>} */
	const ignoreIds = new Set();
	if (Array.isArray(project.ignore)) {
		for (const ignore of project.ignore) {
			if (
				ignore instanceof Object &&
				!Array.isArray(ignore) &&
				!(ignore instanceof Date) &&
				typeof ignore.id === 'string' &&
				!ignoreIds.has(ignore.id)
			)
				ignoreIds.add(ignore.id);
		}
	}

	/** @type {Record<string, import('../src/types').VideoInfo>} */
	const videos = {};

	if (Array.isArray(project.playlist)) {
		for (const playlist of project.playlist) {
			if (
				playlist instanceof Object &&
				!Array.isArray(playlist) &&
				!(playlist instanceof Date) &&
				typeof playlist.id === 'string'
			) {
				const videosInPlaylist = await fetchPlaylist(playlist.id);
				await Promise.all(
					videosInPlaylist
						.filter((video) => !ignoreIds.has(video.resourceId.videoId))
						.map(async (video) => {
							const thumbnail = video.thumbnails && getThumbnail(video.thumbnails);
							const id = video.resourceId?.videoId;
							if (thumbnail == null || id == null) return;
							videos[id] = {
								title: video.title,
								id,
								thumbnail,
								color: await getDominantColor(thumbnail.url),
								squareThumbnail: isAutoGeneratedVideo(video.description),
								description: video.description
							};
						})
				);
			}
		}
	}

	if (Array.isArray(project.video)) {
		/** @type {string[]} */
		const ids = [];
		for (const video of project.video) {
			if (
				video instanceof Object &&
				!Array.isArray(video) &&
				!(video instanceof Date) &&
				typeof video.id === 'string' &&
				!ignoreIds.has(video.id)
			)
				ids.push(video.id);
		}
		const videosRes = await fetchVideos(ids);
		await Promise.all(
			videosRes.map(async (res) => {
				const thumbnail = res.snippet.thumbnails && getThumbnail(res.snippet.thumbnails);
				if (thumbnail == null) return;
				videos[res.id] = {
					title: res.snippet.title,
					id: res.id,
					thumbnail,
					color: await getDominantColor(thumbnail.url),
					squareThumbnail: isAutoGeneratedVideo(res.snippet?.description),
					description: res.snippet?.description
				};
			})
		);
	}

	const projectInfo =
		project.project != null && typeof project.project === 'object' ? project.project : {};

	await writeFile(
		resolve(__dirname, '..', 'src', 'resources.json'),
		JSON.stringify({
			project: projectInfo,
			videos: Object.values(videos)
		})
	);
};

main(process.argv[2])
	.then(() => process.exit())
	.catch((e) => {
		console.error(e);
		process.exit(1);
	});
