/* eslint-disable @typescript-eslint/ban-ts-comment */
// @ts-check
import { getPalette } from 'colorthief';
import { google } from 'googleapis';
import { readFile, writeFile } from 'node:fs/promises';
import { dirname, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';
import { parseProjectToml } from './config.js';

/**
 * @param {string} playlistId Playlist ID
 * @param {string} pageToken nextPageToken
 * @returns {Promise<import('googleapis').youtube_v3.Schema$PlaylistItemSnippet[]>}
 */
const fetchPlaylist = async (playlistId, pageToken = undefined) => {
	const res = await google.youtube('v3').playlistItems.list({
		key: process.env.API_KEY,
		part: ['snippet'],
		maxResults: 50,
		playlistId,
		pageToken
	});

	return res.data.items?.map((item) => item.snippet)?.filter((item) => item != null) ?? [];
};

/**
 * @param {string[]} videoIds Video ID
 * @param {string} pageToken nextPageToken
 * @returns {Promise<import('googleapis').youtube_v3.Schema$Video[]>}
 */
const fetchVideos = async (videoIds, pageToken = undefined) => {
	const res = await google.youtube('v3').videos.list({
		key: process.env.API_KEY,
		part: ['snippet'],
		maxResults: 50,
		id: videoIds,
		pageToken
	});
	const items = res.data.items ?? [];

	return res.data.nextPageToken != null
		? [...items, ...(await fetchVideos(videoIds, res.data.nextPageToken))]
		: items;
};

/**
 * @param {import('googleapis').youtube_v3.Schema$ThumbnailDetails} thumbnailObject
 * @returns {import('googleapis').youtube_v3.Schema$Thumbnail}
 */
const getThumbnail = (thumbnailObject) =>
	thumbnailObject.medium ?? // ~320x180
	thumbnailObject.maxres ?? // ~1280x720
	thumbnailObject.standard ?? // ~640x480
	thumbnailObject.high ?? // ~480x360
	thumbnailObject.default; // ~120x90

/**
 * @param {string} imgUrl
 * @returns {Promise<string>}
 */
const getDominantColor = async (imgUrl) => {
	/** @type {[number, number, number][]} */
	const [dominantColor] = await getPalette(imgUrl, 2, 2);
	return `#${dominantColor.map((v) => v.toString(16).padStart(2, '0')).join('')}`;
};

/**
 * @param {string} description
 * @returns {boolean}
 */
const isAutoGeneratedVideo = (description) =>
	description.match(/^Provided to YouTube.+Auto-generated by YouTube\.$/s) != null;

/**
 * @param {string | undefined} tomlPath
 */
const main = async (tomlPath) => {
	// @ts-ignore
	const __dirname = dirname(fileURLToPath(import.meta.url));
	const _tomlPath =
		tomlPath === undefined ? resolve(__dirname, '..', 'project.toml') : resolve(tomlPath);

	const projectToml = await readFile(_tomlPath, 'utf8');
	const project = parseProjectToml(projectToml);

	const ignoreIds = new Set(project.ignore.map(({ id }) => id) ?? []);

	/** @type {Record<string, import('../src/types').VideoInfo>} */
	const videos = {};

	for (const playlist of project.playlist) {
		const videosInPlaylist = await fetchPlaylist(playlist.id);
		await Promise.all(
			videosInPlaylist
				.filter((video) => !ignoreIds.has(video.resourceId.videoId))
				.map(async (video) => {
					const thumbnail = video.thumbnails && getThumbnail(video.thumbnails);
					const id = video.resourceId?.videoId;
					if (thumbnail == null || id == null) return;
					if (videos[id] != null) {
						videos[id].tags =
							videos[id].tags == null ? [...playlist.tags] : [...videos[id].tags, ...playlist.tags];
					} else {
						videos[id] = {
							title: video.title,
							id,
							thumbnail,
							color: await getDominantColor(thumbnail.url),
							squareThumbnail: isAutoGeneratedVideo(video.description),
							description: video.description,
							tags: [...playlist.tags]
						};
					}
				})
		);
	}

	/** @type {Record<string, string[]>} */
	const idTagMap = Object.fromEntries(project.video.map(({ id, tags }) => [id, tags]));
	const videosRes = await fetchVideos(Object.keys(idTagMap));
	await Promise.all(
		videosRes.map(async (res) => {
			const thumbnail = res.snippet.thumbnails && getThumbnail(res.snippet.thumbnails);
			if (thumbnail == null) return;
			if (videos[res.id] != null) {
				const tags = idTagMap[res.id] ?? [];
				videos[res.id].tags =
					videos[res.id].tags == null ? [...tags] : [...videos[res.id].tags, ...tags];
			} else {
				videos[res.id] = {
					title: res.snippet.title,
					id: res.id,
					thumbnail,
					color: await getDominantColor(thumbnail.url),
					squareThumbnail: isAutoGeneratedVideo(res.snippet?.description),
					description: res.snippet?.description,
					tags: idTagMap[res.id] ?? []
				};
			}
		})
	);

	await writeFile(
		resolve(__dirname, '..', 'src', 'resources.json'),
		JSON.stringify({
			project: project.project,
			videos: Object.values(videos)
		})
	);
};

main(process.argv[2])
	.then(() => process.exit())
	.catch((e) => {
		console.error(e);
		process.exit(1);
	});
