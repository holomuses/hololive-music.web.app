/* eslint-disable @typescript-eslint/ban-ts-comment */
// @ts-check
import { readFile, writeFile } from 'node:fs/promises';
import { dirname, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';
import { parseProjectToml } from './config.js';
import { getDominantColor, getShuffled, getThumbnail, removeDuplicate } from './utils.js';
import { fetchPlaylist, fetchVideos, isAutoGeneratedVideo } from './youtube.js';

/**
 * @param {string | undefined} tomlPath
 */
const main = async (tomlPath) => {
	// @ts-ignore
	const __dirname = dirname(fileURLToPath(import.meta.url));
	const _tomlPath =
		tomlPath === undefined ? resolve(__dirname, '..', 'project.toml') : resolve(tomlPath);

	const projectToml = await readFile(_tomlPath, 'utf8');
	const project = parseProjectToml(projectToml);

	const ignoreIds = removeDuplicate(...project.ignore?.map(({ id }) => id));
	/** @type {Record<string, string[]>} */
	const idTagMap = {};

	const duplicateDefinitions = [];

	/** @type {Record<string, import('../src/types').VideoInfo>} */
	const videos = {};

	for (const playlist of project.playlist ?? []) {
		const videosInPlaylist = await fetchPlaylist(playlist.id);
		const tags = playlist.tags ?? [];
		videosInPlaylist.forEach(({ resourceId }) => {
			if (resourceId.videoId == null) return;
			const exist = idTagMap[resourceId.videoId] ?? [];
			idTagMap[resourceId.videoId] = removeDuplicate(...tags, ...exist);
		});
		console.log('Playlist:', playlist.id);
	}

	for (const video of project.video ?? []) {
		const existTag = idTagMap[video.id];
		const specifiedTag = video.tags ?? [];
		if (existTag == null) {
			idTagMap[video.id] = specifiedTag ?? [];
		} else if (
			existTag.length >= specifiedTag.length &&
			specifiedTag.every((t) => existTag.includes(t))
		) {
			duplicateDefinitions.push(video.id);
		} else {
			idTagMap[video.id] = removeDuplicate(...existTag, ...specifiedTag);
		}
	}

	const videoIds = Object.keys(idTagMap).filter((id) => !ignoreIds.includes(id));

	if (videoIds.length > 0) {
		const videosRes = await fetchVideos(videoIds);
		await Promise.all(
			videosRes.map(async ({ id, snippet, status }) => {
				if (
					snippet?.liveBroadcastContent !== 'none' ||
					status?.privacyStatus !== 'public' ||
					!status.embeddable ||
					id == null ||
					snippet == null
				)
					return;
				const thumbnail = snippet.thumbnails && getThumbnail(snippet.thumbnails);
				if (thumbnail == null) return;
				videos[id] = {
					title: snippet.title,
					id,
					thumbnail,
					color: await getDominantColor(thumbnail.url),
					squareThumbnail: isAutoGeneratedVideo(snippet?.description),
					description: snippet?.description,
					tags: idTagMap[id] ?? []
				};
				console.log('Video:', id);
			})
		);
	}

	const videoList = Object.values(videos);
	await writeFile(
		resolve(__dirname, '..', 'src', 'resources.json'),
		JSON.stringify({
			project: project.project,
			videos: getShuffled(videoList)
		})
	);

	console.log(`Complete with ${Object.keys(videos).length} videos!!!`);
	if (duplicateDefinitions.length > 0)
		console.warn(`Duplicate definitions found: ${duplicateDefinitions.join(', ')}`);

	const notagVideos = videoList.filter(({ tags }) => tags.length === 0);
	if (notagVideos.length > 0)
		console.warn(`No tag video found: ${notagVideos.map(({ id }) => id).join(', ')}`);
};

main(process.argv[2])
	.then(() => process.exit())
	.catch((e) => {
		console.error(e);
		process.exit(1);
	});
